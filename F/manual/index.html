<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<title>The &#402; Manual</title>
	<link rel="stylesheet" href="../../css/styles.css">
	<link rel="stylesheet" href="../../css/pygment_trac.css">
	<link rel="stylesheet" href="../../css/font-awesome.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<script src="../../js/respond.js"></script>
	
	<link href="../../google-code-prettify/prettify.css" type="text/css" rel="stylesheet">
	<link href="../../google-code-prettify/sunburst.css" type="text/css" rel="stylesheet">
	<script type="text/javascript" src="../../google-code-prettify/prettify.js"></script>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<!--[if lt IE 8]>
	<link rel="stylesheet" href="css/ie.css">
	<![endif]-->
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

</head>
<body onload="prettyPrint()">
	<div id="header">
		<nav>
			<li class="downloads"><a href="/"><i class="icon-home"></i> Home</a></li>

			<li class="spacer"></li>
			
			<div class="logo">&#402;<span>.js</span></div>
			
			<!-- <li class="title">GET &#402;</li> -->
		</nav>
	</div><!-- end header -->

	<div class="wrapper">

		<section>
			<div id="title">
				<h1>The &#402; Manual</h1>
				<hr>
			</div>

			<h2>Introduction</h2>
			<ul>
				<li><a href="#whatIsF">What is &#402;?</a></li>
				<li><a href="#buzzwordSoup">Buzzword soup: Models, views, and what?</a></li>
			</ul>


			<h2>Common Tasks</h2>
			<ul>
				<li><a href="#addFToYourProject">Add &#402; to your project</a></li>
				<li><a href="#modelComponent">Fetch and display a model</a></li>
				<li><a href="#formComponent">Edit a model and save changes to the server</a></li>
				<li><a href="#collectionComponent">Fetch and display a collection of models</a></li>
			</ul>


			<h2>Best Practices</h2>
			<ul>
				<li><a href="#applicationDesign">Breaking up your application into components</a></li>
				<li><a href="#componentDesign">Enabling code-reuse with good component design</a></li>
				<li><a href="#domEvents">DOM event delegation</a></li>
			</ul>

			<h2>Miscellaneous</h2>
			<ul>
				<li><a href="#howDoITypeF">How do I type ƒ?</a></li>
			</ul>
		</section>

		<div class="manual">
			<h1>Introduction</h1>
			<hr>
			<section>
				<section id="whatIsF">
					<h2>What is &#402;?</h2>
					<p>&#402; is a component framework for JavaScript applications that promotes code-reuse and frees you from writing boilerplate code.</p>
					<p>&#402; relies heavily on Backbone and jQuery, and is a perfect companion for your templating language of choice.</p>
				</section>
			
				<section id="buzzwordSoup">
					<h2>Buzzword soup: Models, views, and what?</h2>
					<p>Let's avoid the buzzword game and explain we we're talking about.<p>
			
					<section>
						<h3>Models</h3>
						<p>Models are a local representation of an object or database entry. &#402; uses vanilla Backbone models.</p>
						<h3>Templates</h3>
						<p>Templates are HTML structure and template code. Templates control the presentation of your models on the page. &#402; uses vanilla Handlebars templates.</p>
						<h3>Views</h3>
						<p>Views render a model with a given template, putting your data into your HTML structure. Views can be shown or hidden. &#402; uses vanilla Backbone views.</p>
						<h3>Components</h3>
						<p>Components are logical units of application code. They have methods, models, views, and sub-components. A component consists of many sub-components that it connects together by listening to events from one component and calling methods on another.</p>
					</section>
				</section>
			</section>
		
			<h1>Common Tasks</h1>
			<hr>
			<section>
				<section id="addFToYourProject">
					<h2>Add &#402; to your project</h2>

					<ol>
						<li>
							<strong>Get &#402;.</strong> Download a ZIP and extract it.<br>
							<a class="button" href="https://github.com/lazd/F/zipball/master"><i class="icon-download-alt"></i> Download</a></p>
						</li>
						<li>
							<strong>Add the files to your project.</strong> Just dump F.js into your js folder.
						</li>
						<li>
							<strong>Add the script include.</strong> Preferably to the &lt;head&gt; tag.
							<code class="prettyprint">&lt;script src="js/F.js"&gt;&lt;/script&gt;</code>
						</li>
						<li>
							<strong>Get namespaced.</strong> If your app doesn't already have a namespace, create one.
							<code class="prettyprint">var App = {};</code>
						</li>
					</ol>
				</section>
		
				<section id="modelComponent">
					<h2>Fetch and display a model</h2>
					
					<p>&#402; provides F.ModelComponent, which encapsulates some of the common boilerplate code you'd otherwise write when dealing with models.<p>
	
					<ol>
						<li><strong>Define your model.</strong> Your model will need to know where to fetch and save itself.
							<code class="prettyprint">App.Models.Item = Backbone.Model.extend({
	urlRoot: 'api/items'
});</code>
						</li>
						<li><strong>Create a template to display the model's details.</strong> Your template should print the markup and each of the fields
						you want to display.
							
						<code class="prettyprint">App.Templates.ItemDetails = Handlebars.compile(
	'&lt;h2&gt;{{name}}&lt;/h2&gt;'+
	'&lt;p&gt;&lt;a href=&quot;mailto:{{email}}&quot;&gt;{{email}}&lt;/a&gt;&lt;/p&gt;'+
	'{{#if phone}}&lt;p&gt;{{phone}}&lt;/p&gt;{{/if}}'
);</code>
						</li>
						
						<li><strong>Extend F.ModelComponent.</strong> Provide Model and F.ModelComponent will provide methods  you.
							<code class="prettyprint">App.ItemDetails = new Class({
	toString: 'ItemDetails',
	
	extend: F.ModelComponent,
	
	construct: function(options) {
		// Let users specify options; extend defaults
		// so users can specify a new template or model.
		options = _.extend({
			model: this.Model,
			template: this.Template
		}, options);
		
		// Create a view
		this.view = new this.View(options);
	},
	
	// The model we'll be fetching and displaying
	Model: App.Models.Item,
	
	View: F.View.extend({
		events: {
			'click .sendMessage': 'doSend'
		}
	}),
	
	Template: App.Templates.ItemDetails
});</code>
						</li>
						
						<li><strong>Display a model.</strong> Give the show() method an ID and F.ModelComponent will fetch it from the server for you. You can also directly pass the model to show(), which is useful when editing a model you have already loaded (such as part of a list).
							<code class="prettyprint">// Generally, you'll add the editor as a component
// For this example, we'll just create an instance
app.details = new App.ItemDetails();

// Display the model with the ID=10, fetching it from the server first
app.details.show({ id: 10 });

// If you already have the model, call show and pass it directly
var tempModel = new App.Models.Item({
	name: 'Larry Davis',
	email: 'lazd@fake.em.ail'
});
app.details.show({
	model: tempModel
});
</code>
					</ol>
			
					<p>See the <a href="http://lazd.github.com/F/F/examples/Contacts">Contacts example</a> for a live demo.</p>
				</section>
		
				<section id="formComponent">
					<h2>Edit a model and save changes to the server</h2>
					
					<p>&#402; provides F.FormComponent, which handles fetching models from the server, rendering the corresponding edit form, and asynchronously saving changes.<p>
						
					<ol>
						<li><strong>Define your model.</strong> Your model will need to know where to fetch and save itself.
							<code class="prettyprint">App.Models.Item = Backbone.Model.extend({
	urlRoot: 'api/items'
});</code>
						<li><strong>Create a template for your form.</strong> You'll need to create a template that has input fields for each one of the properties you want to expose for editing.
							
						<code class="prettyprint">App.Templates.ItemEditor = Handlebars.compile(
	'&lt;label&gt;Name&lt;/label&gt;'+
	'&lt;input type="text" name="name" value="{{name}}"&gt;'+
	'&lt;label&gt;E-mail&lt;/label&gt;'+
	'&lt;input type="text" name="email" value="{{email}}"&gt;'+
	'&lt;label&gt;Phone&lt;/label&gt;'+
	'&lt;input type="text" name="phone" value="{{phone}}"&gt;'+
	'&lt;button type="submit"&gt;Save&lt;/button&gt;'
);</code>
						</li>
						<li><strong>Extend F.FormComponent.</strong> Provide Model and Template, and F.FormComponent will do the rest.
							<code class="prettyprint">App.ItemEditor = new Class({
	toString: 'ItemEditor',
	
	extend: F.FormComponent,

	// Indicate the model you'll be loading and saving
	Model: App.Models.Item,
	
	Template: App.Templates.ItemEditor
});</code>
						</li>
						<li><strong>Load a model for editing.</strong> Give the show() method an ID and F.ModelComponent will fetch it from the server for you. You can also directly pass the model to show(), which is useful when editing a model you have already loaded (such as if a user clicked an Edit button from the details view).
							<code class="prettyprint">// Generally, you'll add the editor as a component
// For this example, we'll just create an instance
app.editor = new App.ItemEditor();

// Do something on a successful save
app.editor.on('saved', function() {
	alert('Changes saved!');
});

// Do something when the save fails
app.editor.on('saveFailed', function() {
	alert('ERROR: Failed to save changes!');
});

// Edit the model with the ID=10, fetching it from the server first
app.editor.show({ id: 10 });

// If you already have the model, call show and pass it directly
var tempModel = new App.Models.Item({
	name: 'Larry Davis',
	email: 'lazd@fake.em.ail'
});
app.editor.show({
	model: tempModel
});</code>
						</li> 
					</ol>
			
					<p>See the <a href="http://lazd.github.com/F/F/examples/Contacts">Contacts example</a> for a live demo.</p>
				</section>
		
				<section id="collectionComponent">
					<h2>Fetch and display a collection of models</h2>
			
					<p>See the <a href="http://lazd.github.com/F/F/examples/Contacts">Contacts example</a> for a live demo.</p>
				</section>
			</section>
				
			<h1>Best Practices</h1>
			<hr>
			<section>
				<section id="applicationDesign">
					<h2>Breaking up your application into components</h2>
					<p>Coming soon.</p>

					<h3>Why have nested components?</h3>
					<p>Coming soon.</p>
			
					<h3>What should be a component and what shouldn't?</h3>
					<p>Coming soon.</p>
				</section>
				
				<section id="componentDesign">
					<h2>Enabling code-reuse with good component design</h2>
					<p>Designing for one use case and moving on is easy the first time, but when you're writing the same boilerplate code for every part of your project, it's time to go back to the drawing board.</p>

					<h3>Look for opportunities to abstract</h3>
					<p>That block of code you keep pasting into every component should really be part of a parent class from which you inherit.<p>
						<code class="prettyprint">App.Hustler = new Class({
	toString: 'Hustler',

	extend: F.Component,

	construct: function(options) {
		this.hustle();
	},

	hustle: function() {
		// This line of code is boilerplate;
		// that is, we have it in all related components
		alert("I'm a "+this.toString());
	}
});

App.HustlerBaby = new Class({
	toString: 'HustlerBaby',

	// Inherit from Hustler so we get hustle()
	extend: App.Hustler,

	hustle: function() {
		// Instead of re-writing the boilerplate code,
		// call the parent class' hustle method
		this.inherited(arguments);
		
		// Do additional stuff
		alert('I just want you to know');
	}
});
</code>

					<h3>Put it in the prototype</h3>
					<p>Declare your models, views, and templates in the prototype of the components you create. This lets child classes easily override them.<p>
				</section>
				
				<section id="domEvents">
					<h2>DOM event delegation</h2>
					<p>When you have many items that all need to handle the same event, instead of adding one listener for each item, add a listener to the parent container. This helps performance when your list has thousands of items.</p>
					<p><strong>But how do I know which item got the click?</strong> Use evt.target to determine the DOM node that got the click. If that node is associated with some data (a model, for instance), then use $(node).data('model', theModel) to store and retrieve the model. F.ListComponent will store the model in the node's data for you.
					<code class="prettyprint">App.PhotoGrid = new Class({
	toString: 'PhotoGrid',

	extend: F.ListComponent,
	
	Collection: Backbone.Collection.extend(),
	
	ItemTemplate: Handlebars.compile(
		'&lt;img src=&quot;{{url}}&quot;&gt;'
	),
	
	// Extend ListComponent, override its events
	View: F.ListComponent.prototype.ListView.extend({
		tag: 'ul',
		className: 'photoGrid',
		events: {
			'mouseover li': 'handleMouseover'
		}
	}),
	
	handleMouseover: function(evt) {
		var target = $(evt.target);
		var model = target.data('model');
		console.log(model.name+' has the mouse over it!');
	}
});</code>
				</section>
				
			</section>
		
			<h1>Miscellaneous</h1>
			<hr>
			<section>
				<section id="howDoITypeF">
					<h2>How do I type ƒ?</h2>
					<p>Yes, ƒ is a valid JavaScript variable name, and you use it instead of F if you're super hip.</p>
					<section>
						<section>
							<strong>Mac:</strong> Option + f<br>
							<strong>Windows:</strong> alt + 1 5 9
						</section>
					</section>
				</section>
			</section>
		</div>
	</div>
	<!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->

	<span class="credits">Maintained by <a href="https://github.com/lazd">lazd</a></span>
	<!-- <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></span> -->
</body>
</html>
